#!/usr/bin/env node
// clarity-loop/hooks/generate-manifest.js
// PostToolUse hook: regenerates {docsRoot}/system/.manifest.md when system docs change.
// Also callable directly with --init flag from init.js/init.sh.
//
// Reads tool input from stdin (JSON) to detect if a system doc was modified.
// Parses ## headings with line ranges, detects cross-references, computes SHA-256.
// Output: {docsRoot}/system/.manifest.md (~2-5KB)

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { loadConfig, resolveDocPath } = require('./config');

function findMdFiles(dir) {
  const results = [];
  let entries;
  try {
    entries = fs.readdirSync(dir, { withFileTypes: true });
  } catch {
    return results;
  }

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      // One level of nesting (maxdepth 2 equivalent)
      try {
        const subEntries = fs.readdirSync(fullPath, { withFileTypes: true });
        for (const sub of subEntries) {
          if (sub.isFile() && sub.name.endsWith('.md') && sub.name !== '.manifest.md') {
            results.push(path.join(fullPath, sub.name));
          }
        }
      } catch {
        // Skip unreadable subdirs
      }
    } else if (entry.isFile() && entry.name.endsWith('.md') && entry.name !== '.manifest.md') {
      results.push(fullPath);
    }
  }

  return results.sort();
}

function main() {
  const forceRun = process.argv.includes('--init');

  // Resolve project root
  const projectRoot = process.env.CLARITY_LOOP_PROJECT_ROOT || process.cwd();
  const config = loadConfig(projectRoot);
  const systemDir = resolveDocPath(projectRoot, config, 'system');
  const manifestPath = path.join(systemDir, '.manifest.md');

  if (!forceRun) {
    // Read hook input from stdin to check if a system doc was edited
    let input = '';
    try {
      input = fs.readFileSync(0, 'utf8');
    } catch {
      process.exit(0);
    }

    let filePath = '';
    try {
      const data = JSON.parse(input);
      const toolInput = data.tool_input || {};
      filePath = toolInput.file_path || '';
    } catch {
      process.exit(0);
    }

    // Normalize for consistent matching (backslashes to forward slashes)
    const normalizedPath = filePath.replace(/\\/g, '/');
    const systemPrefix = config.docsRoot + '/system/';

    // Only regenerate if the edited file is in {docsRoot}/system/ at a path boundary
    const prefixIndex = normalizedPath.indexOf(systemPrefix);
    if (prefixIndex < 0 || (prefixIndex > 0 && normalizedPath[prefixIndex - 1] !== '/')) {
      process.exit(0);
    }

    // Skip if the edited file IS the manifest
    const afterPrefix = normalizedPath.substring(prefixIndex + systemPrefix.length);
    if (afterPrefix === '.manifest.md' || afterPrefix.startsWith('.manifest.md')) {
      process.exit(0);
    }
  }

  // --- Check for system docs ---
  if (!fs.existsSync(systemDir)) {
    process.exit(0);
  }

  const mdFiles = findMdFiles(systemDir);
  if (mdFiles.length === 0) {
    process.exit(0);
  }

  // --- Generate manifest ---
  const timestamp = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');

  // Compute combined content hash
  const hash = crypto.createHash('sha256');
  for (const f of mdFiles) {
    hash.update(fs.readFileSync(f));
  }
  const combinedHash = hash.digest('hex');

  // Start building manifest content
  const lines = [];
  lines.push('# System Doc Manifest');
  lines.push('');
  lines.push('> Auto-generated by Clarity Loop. Do not edit manually.');
  lines.push(`> **Generated**: ${timestamp}`);
  lines.push(`> **Content hash**: \`${combinedHash.substring(0, 16)}\``);
  lines.push(`> **Documents**: ${mdFiles.length}`);
  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push('## Documents');
  lines.push('');
  lines.push('| File | Lines | Sections | Last Modified |');
  lines.push('|------|-------|----------|---------------|');

  const sectionIndexParts = [];
  const crossRefs = [];

  for (const filepath of mdFiles) {
    const filename = path.basename(filepath);
    const content = fs.readFileSync(filepath, 'utf8');
    const contentLines = content.split('\n');
    // Count visual lines of content (not wc -l which counts newline characters)
    const lineCount = content === '' ? 0 : (content.endsWith('\n') ? contentLines.length - 1 : contentLines.length);

    // Get last modified date
    let lastModified = 'unknown';
    try {
      const stat = fs.statSync(filepath);
      lastModified = stat.mtime.toISOString().substring(0, 10);
    } catch {
      // Keep 'unknown'
    }

    // Count ## headings (sections)
    let sectionCount = 0;
    for (const line of contentLines) {
      if (/^##/.test(line)) {
        sectionCount++;
      }
    }

    lines.push(`| ${filename} | ${lineCount} | ${sectionCount} | ${lastModified} |`);

    // --- Build section index for this file ---
    const fileSections = [];
    fileSections.push('');
    fileSections.push(`### ${filename}`);

    let prevHeading = '';
    let prevLine = 0;

    for (let i = 0; i < contentLines.length; i++) {
      const line = contentLines[i];
      if (/^#{1,4}\s/.test(line)) {
        if (prevHeading) {
          fileSections.push(`- ${prevHeading} (lines ${prevLine}-${i})`);
        }
        prevHeading = line;
        prevLine = i + 1; // 1-based line numbers
      }
    }

    // Last heading runs to end of file
    if (prevHeading) {
      fileSections.push(`- ${prevHeading} (lines ${prevLine}-${lineCount})`);
    }

    sectionIndexParts.push(fileSections.join('\n'));

    // --- Detect cross-references ---
    for (const otherFile of mdFiles) {
      const otherName = path.basename(otherFile);
      if (otherName !== filename) {
        if (content.includes(otherName)) {
          crossRefs.push(`- ${filename} -> ${otherName}`);
        }
      }
    }
  }

  // Assemble final manifest
  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push('## Section Index');
  lines.push(sectionIndexParts.join('\n'));
  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push('## Cross-References');

  if (crossRefs.length > 0) {
    lines.push(crossRefs.join('\n'));
  } else {
    lines.push('No cross-references detected.');
  }

  lines.push('');

  // Write the manifest
  fs.writeFileSync(manifestPath, lines.join('\n'));
}

main();
